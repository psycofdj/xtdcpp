<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>xtd [network]: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">xtd [network]
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">xtd [network] Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>La bibliothèque <a class="el" href="namespacextd_1_1network.html">xtd::network</a> est la base de toutes les communications réseaux utilisée dans le moteur.</p>
<p>Elle s'appuie sur la bibliothèque boost::asio pour fournir des interfaces de haut niveau de client/serveur http et bip (binary-protocol).</p>
<h1><a class="anchor" id="sec_main"></a>
Sommaire</h1>
<hr/>
 <ol>
<li>
<p class="startli"><a class="el" href="index.html#sec_boost">Un mot sur boost::asio</a> </p><ol>
<li>
<a class="el" href="index.html#ssec_boost_practice">Les bonnes pratiques</a>  </li>
<li>
<a class="el" href="index.html#ssec_boost_bug">Bug dans la version 1.48</a>  </li>
</ol>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="index.html#sec_design">Le design</a> </p><ol>
<li>
<a class="el" href="index.html#ssec_design_obj1">Objectif n°1 : mutualiser la gestion des sockets entre client et serveur</a>  </li>
<li>
<a class="el" href="index.html#ssec_design_obj2">Objectif n°2 : rester procotole agnostique</a>  </li>
</ol>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="index.html#sec_bip">Protocol Bip</a> </p><ol>
<li>
<a class="el" href="index.html#ssec_bip_cnx">Format et workflow</a>  </li>
<li>
<a class="el" href="index.html#ssec_bip_client">Client bip</a>  </li>
<li>
<a class="el" href="index.html#ssec_bip_server">Serveur bip</a>  </li>
</ol>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="index.html#sec_http">Protocol HTTP</a> </p><ol>
<li>
<a class="el" href="index.html#ssec_http_cnx">Format et workflow</a>  </li>
<li>
<a class="el" href="index.html#ssec_http_server">Serveur http</a>  </li>
</ol>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="index.html#sec_usages">Matrice d'utilisation</a> </p>
<p class="endli"></p>
</li>
<li>
<a class="el" href="index.html#sec_tests">Les tests</a>  </li>
</ol>
<p><br />
<br />
</p>
<hr/>
 <h1><a class="anchor" id="sec_boost"></a>
Un mot sur boost::asio</h1>
<hr/>
<p>Boost::asio (<a href="http://www.boost.org/doc/libs/1_48_0/doc/html/boost_asio.html">http://www.boost.org/doc/libs/1_48_0/doc/html/boost_asio.html</a>) est une bibliothèque réseau et I/O écrite en c++ et utilisée dans de nombreux software.<br />
 <b>Son utilisation n'est pas triviale</b>, aussi la première chose à faire est de bien lire la documentation et se familiariser avec la gestion des événements asynchrones et de l'utilisation du boost::asio::io_service.<br />
</p>
<p><br />
 </p>
<h2><a class="anchor" id="ssec_boost_practice"></a>
Les bonnes pratiques</h2>
<p>Pour résumer, on retiendra de la documentation :</p>
<ol type="1">
<li>qu'il est fortement <b>déconseillé</b> de mélanger synchrone et asynchrone</li>
<li>qu'il n'est pas possible d'utiliser des timeouts en synchrone. En réalité, on peut fermer la socket pendant l'éxécution d'un événement synchrone mais cette approche n'est pas "naturelle" pour le framework boost::asio est cela nous a posé beaucoup de problème en production.</li>
<li>qu'il faut, en toutes circonstance, garantir la durée de vie des objets et données utilisée dans les callback des événements asynchrones. L'utilisation des shared_ptr sera ici très utile.</li>
<li>qu'il est possible de débugguer la gestion des événements à l'aide de la macro <b>-DBOOST_ASIO_ENABLE_HANDLER_TRACKING</b> (<a href="http://www.boost.org/doc/libs/1_48_0/doc/html/boost_asio/overview/core/handler_tracking.html">http://www.boost.org/doc/libs/1_48_0/doc/html/boost_asio/overview/core/handler_tracking.html</a>)</li>
</ol>
<p><br />
 </p>
<h2><a class="anchor" id="ssec_boost_bug"></a>
Bug dans la version 1.48</h2>
<p>Aujourd'hui (18-10-2013), on utilise boost::asio en compilant avec la macro <b>-DBOOST_ASIO_DISABLE_EPOLL</b>. Cette macro a pour effet de forcer l'utilisation de l'appel systeme "select" a la place de son jeune remplaçant "epoll".</p>
<p>Ce point nous a posé énormément de problèmes. Pendant plusieurs semaines, des simples "toy problem" ne marchaient pas dès que le serveur avait plus qu'une thread en écoute sur son boost::asio::io_service. De temps en temps, le client envoyait une requête, les données traversent le réseaux (wireshark) mais le serveur ne déclenche pas son événement de lecture de donnée sur la socket... rien ne se passe et la socket est perdue.</p>
<p>On a jamais trouvé l'explication finale de ce problème, ni de bug précis dans le tracker boost ni d'explication à la lecture du code. Toujours est-il qu'un faisceau d'indices nous a fait conclure à une faille de boost::asio dans sa gestion du epoll.</p>
<p>Les indices étants :</p><ul>
<li>de nombreuse va-et-vient dans les changelog asio sur le epoll entre la version 1.48 (qu'on utilise) et la version 1.54 actuelle</li>
<li>la disparition de ces problèmes lorsqu'on passe en select</li>
<li>la disparition de ces problèmes lorsqu'on passe en boost::asio 1.52</li>
</ul>
<p><br />
</p><hr/>
 <h1><a class="anchor" id="sec_design"></a>
Le design</h1>
<hr/>
<p>Le design de la bibliothèque <a class="el" href="namespacextd_1_1network.html">xtd::network</a> est composé de deux couches :</p><ul>
<li>la couche haute xtd::network::protocol qui implémentent les clients serveurs pour les protocoles HTTP et BIP utilisés dans le moteur</li>
<li>la couche basse <a class="el" href="namespacextd_1_1network_1_1base.html">xtd::network::base</a> qui fournie les primitives de bas niveau pour l'implémentation de ces protocoles.</li>
</ul>
<h2><a class="anchor" id="ssec_design_obj1"></a>
Objectif n°1 : mutualiser la gestion des sockets entre client et serveur</h2>
<p>Pour y parvenir, on crée un objet "Connection" qui sera utilisé à la fois dans le client et dans le serveur. Cet objet fera office d'interface avec la socket en proposant des primitives simples d'ouverture, d'envoi et de réception de données.</p>
<p>De plus, cet objet va nous aider dans la gestion du multithreading en garantissant, en travaillant sur son propre boost::asio::strand, qu'une seule opération soit exécutée à la fois.</p>
<p>On se retrouve donc à définir 3 objets dans cette couche basse :</p><ul>
<li><a class="el" href="classxtd_1_1network_1_1base_1_1Connection.html" title="Base class from which all connections should derive. ">xtd::network::base::Connection</a> : un objet s'occupant des interactions avec la socket</li>
<li><a class="el" href="classxtd_1_1network_1_1base_1_1Client.html">xtd::network::base::Client</a> : un client</li>
<li><a class="el" href="classxtd_1_1network_1_1base_1_1Server.html">xtd::network::base::Server</a> : un serveur</li>
</ul>
<div class="image">
<img src="interface.png" alt="interface.png"/>
</div>
<p>On parlera de triplet client/server/connection : </p><div class="image">
<img src="triplet.png" alt="triplet.png"/>
</div>
<h2><a class="anchor" id="ssec_design_obj2"></a>
Objectif n°2 : rester procotole agnostique</h2>
<p>On définit un protocol comme étant :</p><ul>
<li>le format du message échangé : quelle langue parlent les deux interlocuteurs et, en particulier, comment font-il pour savoir qu'un message est terminé (problème du morcelement des packets par le transport TCP/IP).</li>
<li>la séquence du dialogue : qui commence à parler ? qui commence à écouter ? En tout temps, il faut qu'un interlocuteur écoute lorsque l'autre parle et vis/versa.</li>
</ul>
<p>Pour rester agnostique du protocol, notre triplet (client, server, connexion) ne doit pas faire de supposition ni le format du message ni sur l'enchaînement des envois et des réceptions. En ce qui concerne le format, cela implique que la <a class="el" href="classxtd_1_1network_1_1base_1_1Connection.html" title="Base class from which all connections should derive. ">xtd::network::base::Connection</a> ne peut pas directement écrire et lire sur la socket. Dans certains cas, on voudra lire une donnée de taille fixe, dans d'autres cas, un header puis une data, bref, on il faut déléguer ces opérations à la couche xtd::network::protocol. En ce qui concerne l'enchainement des envois/receptions, cela implique que ces objets ne peuvent pas lancer une réception ou un envoi, ils ne peuvent que définir ces primitives mais sans jamais les appeler.</p>
<p>Au final, on se retrouve avec :</p>
<ul>
<li><a class="el" href="classxtd_1_1network_1_1base_1_1Connection.html" title="Base class from which all connections should derive. ">xtd::network::base::Connection</a> :<ul>
<li>ownership de la socket</li>
<li>gestion des envois de message avec timeout (partie abstraite de création et mise sur le socket du message)</li>
<li>gestion des réceptions de message avec timeout (partie abstraite de décodage et lecture sur le socket du message)</li>
<li>gestion ouverture et fermeture de la socket</li>
</ul>
</li>
<li><a class="el" href="classxtd_1_1network_1_1base_1_1Client.html">xtd::network::base::Client</a> :<ul>
<li>gère l'instanciation d'un connexion</li>
<li>la connexion vers un serveur (utilise <a class="el" href="classxtd_1_1network_1_1base_1_1Connection.html#a65d8b3807020454530e47a7591bcd3e4" title="connexion aynchrone de socket (client only) ">xtd::network::base::Connection::connect</a>)</li>
<li>l'envoie d'un message (utilise <a class="el" href="classxtd_1_1network_1_1base_1_1Connection.html#ac63ae08b1b21b4203c35222de15cdf03" title="envoi asynchrone d&#39;un message sur la socket ">xtd::network::base::Connection::send</a>)</li>
<li>la réception d'un message (utilise <a class="el" href="classxtd_1_1network_1_1base_1_1Connection.html#a02ebf6ddba3495ec18c8a99c683da06a" title="reception asynchrone d&#39;un message de la socket ">xtd::network::base::Connection::receive</a>)</li>
<li>la fermeture de la connexion (utilise <a class="el" href="classxtd_1_1network_1_1base_1_1Connection.html#a73097d339a3716c05fee7ee19753ee4a" title="fermeture de la socket et annule ses operations de lecture ecriture ">xtd::network::base::Connection::close</a>)</li>
<li>les compteurs d'exploitation</li>
</ul>
</li>
<li><a class="el" href="classxtd_1_1network_1_1base_1_1Server.html">xtd::network::base::Server</a> :<ul>
<li>l'initialisation des threads de traitement et de connexion</li>
<li>l'ouverture d'une connexion entrante (utilise <a class="el" href="classxtd_1_1network_1_1base_1_1Connection.html#a7854932a250db5ed14426abad97da64a" title="ouverture aynchrone de socket (server only) ">xtd::network::base::Connection::accept</a>)</li>
<li>réception d'un message (utilise <a class="el" href="classxtd_1_1network_1_1base_1_1Connection.html#a02ebf6ddba3495ec18c8a99c683da06a" title="reception asynchrone d&#39;un message de la socket ">xtd::network::base::Connection::receive</a>)</li>
<li>envoie d'un message (utilise <a class="el" href="classxtd_1_1network_1_1base_1_1Connection.html#ac63ae08b1b21b4203c35222de15cdf03" title="envoi asynchrone d&#39;un message sur la socket ">xtd::network::base::Connection::send</a>)</li>
<li>fermeture des connexion (utilise <a class="el" href="classxtd_1_1network_1_1base_1_1Connection.html#a73097d339a3716c05fee7ee19753ee4a" title="fermeture de la socket et annule ses operations de lecture ecriture ">xtd::network::base::Connection::close</a>)</li>
<li>les compteurs d'exploitation</li>
</ul>
</li>
</ul>
<p>Ensuite, chaque protocole n'a plus qu'a définir ses spécificités en créant son propre son triplet de client/server/connexion qui dérive du triplet de base.<br />
 Au final ou abouti au modèle suivant :</p>
<div class="image">
<img src="diagram.png" alt="diagram.png"/>
</div>
<p><br />
</p><hr/>
 <h1><a class="anchor" id="sec_bip"></a>
Protocol Bip</h1>
<hr/>
<p><br />
 </p>
<h2><a class="anchor" id="ssec_bip_cnx"></a>
Format et workflow</h2>
<h2>Format </h2>
<p>Un message bip est composé de deux parties :</p><ul>
<li>un header : une suite de Connection::mcs_headerSize uint32_t (donc taille fixe)</li>
<li>une data : une suite de taille variable de uint8</li>
<li>un crc de data : un crc en uint8 calculé sur les Connection::mcs_maxDataCrcSize derniers octects de la partie donnée.</li>
</ul>
<p>Le header embarque 3 informations :</p><ul>
<li>la taille de la partie donnée (comptabilise le crc finale) en nombre d'octect</li>
<li>un identifiant de requête croissant (s'incrémente à chaque requete)</li>
<li>un crc de header calculé sur les (Connection::mcs_headerSize - 1) unit32 du header</li>
</ul>
<p>A la réception :</p><ul>
<li>on commence par lire le header</li>
<li>on vérifie l'integrité du header en comparant le crc de header reçu et le crc du header re-calculé</li>
<li>on extrait la taille du message N attendu a partir du header, on on va lire sur la socket ces N octects.</li>
</ul>
<p>A la réception de la partie donnée :</p><ul>
<li>on vérifie l'intégrité du message en comparant le crc de donnée contenu dans dernier octet du message au crc recalculé.</li>
</ul>
<h2>Séquence de dialogue </h2>
<div class="image">
<img src="bip_flow.png" alt="bip_flow.png"/>
</div>
<p><br />
 </p>
<h2><a class="anchor" id="ssec_bip_client"></a>
Client bip</h2>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TDomain</td><td>: mode de connexion, utils::af_inet ou utils::af_unix </td></tr>
    <tr><td class="paramname">TRequest</td><td>Structure requète serialisable avec boost::serialization </td></tr>
    <tr><td class="paramname">TResponse</td><td>Structure réponse serialisable avec boost::serialization</td></tr>
  </table>
  </dd>
</dl>
<p>Client générique bip : gère l'envoi de structure TRequest et la réception de structure TResponse vers un serveur bip de même type.</p>
<p>Selon la configuration transmise au constructeur, les données pourront etre compressées avant l'envoi et décompressée à la réception.</p>
<p>La méthode send de cet objet est non bloquante et déclenche, en interne, la réception de la réponse du serveur. La méthode receive, elle, est bloquante jusqu'à la réception effective de la réponse. Cette approche permet à un utilisateur, qui aurait plusieurs client connectés vers plusieurs serveurs, d'envoyer ses requètes et de réceptionner en parallèle ses réponses pour au final aller au rythme du serveur le plus lent et pas subir la somme de tous les temps de réponse.</p>
<p>Thread safety :</p><ul>
<li>même instance : non</li>
<li>instances différentes : oui</li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="ssec_bip_server"></a>
Serveur bip</h2>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Domain</td><td>: mode de connexion, utils::af_inet ou utils::af_unix </td></tr>
    <tr><td class="paramname">TReq</td><td>: Structure requête serialisable avec boost::serialization </td></tr>
    <tr><td class="paramname">TRes</td><td>: Structure réponse serialisable avec boost::serialization</td></tr>
  </table>
  </dd>
</dl>
<p>Serveur générique bip : gère la réception de structure TRequest et l'envoi de structure TResponse vers un client bip de même type.</p>
<p>Cet objet est destiné à être hérité des différents serveurs qui souhaitent communiquer en bip, ces derniers n'ont qu'a implémenter la méthode virtuelle pure Server::processObjectRequest pour calculer la réponse à envoyer à partir de la requête reçue</p>
<p><br />
</p><hr/>
 <h1><a class="anchor" id="sec_http"></a>
Protocol HTTP</h1>
<hr/>
<p><br />
 </p>
<h2><a class="anchor" id="ssec_http_cnx"></a>
Format et workflow</h2>
<p>Le protocol http implémenté ici gère les version 1.0 et une sous-partie de la version 1.1 des spécifications données par le W3C. </p><h2>Format</h2>
<p>Un message HTTP est composé de deux parties :</p><ul>
<li>un header : une suite de caractère ascii de taille variable terminant par une ligne vide (donc identifiable par la séquence d'octets "CR-LF-CR-LR")</li>
<li>une data : une suite de caractère ascii de taille variable, optionnelle et potentiellement encodée dans différents formats</li>
</ul>
<p>Sans rentrer dans le détail du format du header, ce qui nous intéresse ici c'est que, lorsqu'une data est envoyée, il contient une directive <b>Content-Length</b> qui renseigne sur la taille en octet de la data.</p>
<p>A la réception, on lit des données par petits bouts jusqu'à trouver la fin du header (ligne vide), on extrait ensuite la taille de la donnée et, si elle présente et est non-nulle, on se met à lire jusqu'à avoir suffisamment d'octets.</p>
<p>Pour des raisons pratique, le parsing du header et la récupération de la taille de la data est déléguée à l'objet <a class="el" href="classxtd_1_1network_1_1http_1_1Request.html">xtd::network::http::Request</a></p>
<h2>Séquence de dialogue </h2>
<div class="image">
<img src="http_flow.png" alt="http_flow.png"/>
</div>
<p><br />
 </p>
<h2><a class="anchor" id="ssec_http_server"></a>
Serveur http</h2>
<p><br />
<br />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Domain</td><td>mode de connexion, utils::af_inet ou utils::af_unix</td></tr>
  </table>
  </dd>
</dl>
<p>Serveur générique http. Gère la réception de requête HTTP, les transforme en objet Request, et envoie des réponses HTTP à partir d'objet Response.</p>
<p>En interne, cet objet gère une liste de "handlers", capables de transformer un objet Request en un objet Response. Il gère également un mécanisme d'enregistrement et de routage des requête ces différents handlers.</p>
<p><br />
 </p><h2>Le routage </h2>
<p>Le routage est extrêmement simple. On pacourt la liste des handlers enregistrés, et on exécute le premier vérifiant toutes les conditions. Si aucun handler est trouvé, on exécute le handler par défaut.</p>
<p>Pour être exécuté, un handler doit remplir deux critère :</p><ul>
<li>l'url sur laquelle il à été enregistré correspond a la ressource demandée dans la requête (ce qui suit le GET ou le POST de la première ligne du header). On note le cas spécial où un handler peut être enregistré sur toutes les urls en même temps.</li>
<li>si le handler a été enregistré avec un filtre, on vérifie la condition posée le filtre est vrai pour la requête.</li>
</ul>
<p><br />
 </p><h2>Les handlers </h2>
<p>Un handler doit être vu comme un pointeur sur fonction dont le prototype serait : </p><div class="fragment"><div class="line">status myhandler(uint32_t p_requestID, <span class="keyword">const</span> Request&amp; p_req, Response&amp; p_res);</div></div><!-- fragment --><p>En réalité, cet objet demande à ce que les handlers soient construit à partir de ses classes internes, dont le raccourcis est "h". Exemple : </p><div class="fragment"><div class="line"><span class="comment">// une fonction à moi que j&#39;aime</span></div><div class="line">status MyServer::myhandler(uint32_t p_requestID, <span class="keyword">const</span> Request&amp; p_req, Response&amp; p_res);</div><div class="line"></div><div class="line"><span class="comment">// enregistrement de ma fonction comme handler de la ressources /index</span></div><div class="line">bind(<span class="stringliteral">&quot;/index&quot;</span>, h(&amp;MyServer::myhandler, <span class="keyword">this</span>));</div></div><!-- fragment --><p>La raison pour laquelle ces handlers ont été wrappé dans un objet interne est d'une part de ne pas demander à l'utilisateur de systématiquement binder 3 placeholders _1, _2, _3.</p>
<p><br />
 </p><h2>Les filtres </h2>
<p>De la même façon, les filtres doivent être vus comme un pointeur sur fonction dont le prototype serait : </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> filter(<span class="keyword">const</span> Request&amp;);</div></div><!-- fragment --><p>Ils se contruisent à partir de l'objet interne du server dont le raccourcis est "f". Exemple : </p><div class="fragment"><div class="line"><span class="comment">// une fonction à moi que j&#39;aime</span></div><div class="line">status MyServer::myhandler(uint32_t p_requestID, <span class="keyword">const</span> Request&amp; p_req, Response&amp; p_res);</div><div class="line"><span class="keywordtype">bool</span>  MyServer::myfilter(<span class="keyword">const</span> Request&amp; p_req);</div><div class="line"></div><div class="line"><span class="comment">// enregistrement de ma fonction comme handler de la ressources /index</span></div><div class="line">bind(<span class="stringliteral">&quot;/index&quot;</span>, h(&amp;MyServer::myhandler, <span class="keyword">this</span>), f(&amp;MyServer::myfilter, <span class="keyword">this</span>));</div></div><!-- fragment --><p>Ils ont également une autre fonctionnalité, il peuvent se composer avec les opérateurs standards booléens ||, &amp;&amp; et !. Exemple :</p>
<div class="fragment"><div class="line"><span class="comment">// une fonction à moi que j&#39;aime</span></div><div class="line">status MyServer::myhandler(uint32_t p_requestID, <span class="keyword">const</span> Request&amp; p_req, Response&amp; p_res);</div><div class="line"><span class="keywordtype">bool</span>  MyServer::hasHeader(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_headerName, <span class="keyword">const</span> Request&amp; p_req)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> p_req.existsHeader(p_headerName);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// enregistrement de ma fonction comme handler de la ressources /index</span></div><div class="line">bind(<span class="stringliteral">&quot;/index&quot;</span>,</div><div class="line">     h(&amp;MyServer::myhandler, <span class="keyword">this</span>),</div><div class="line">     f(&amp;MyServer::hasHeader, <span class="keyword">this</span>, <span class="stringliteral">&quot;Content-type&quot;</span>) &amp;&amp;</div><div class="line">     f(&amp;MyServer::hasHeader, <span class="keyword">this</span>, <span class="stringliteral">&quot;Content-Length&quot;</span>));</div></div><!-- fragment --><p><br />
 </p><h2>L'enregistrement </h2>
<p>Cet objet founi de nombreuses méthodes utilitaires pour faciliter l'enregistrement des handlers. Elles sont toutes préfixées par "bind".</p>
<ul>
<li><div class="fragment"><div class="line"><span class="keywordtype">void</span> bind(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_url, handler p_handler, [filter p_filter]); </div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_url</td><td>ressource à enregistrer </td></tr>
    <tr><td class="paramname">p_handler</td><td>handler à enregistrer </td></tr>
    <tr><td class="paramname">p_filter</td><td>filter "filtre" optionnel </td></tr>
    <tr><td class="paramname">p_descr</td><td>description du handler (optionnel)</td></tr>
  </table>
  </dd>
</dl>
Enregistrement générique de la ressource p_url sous condition optionnelle p_filter sur le handler p_handler. <br />
<br />
</li>
<li><div class="fragment"><div class="line"><span class="keywordtype">void</span> bind_any(handler p_handler, [filter p_filter]); </div></div><!-- fragment --> <br />
<br />
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_handler</td><td>handler à enregistrer </td></tr>
    <tr><td class="paramname">p_filter</td><td>filter "filtre" optionnel</td></tr>
  </table>
  </dd>
</dl>
Comme <a class="el" href="classxtd_1_1network_1_1http_1_1Server.html#abd0a9f6c34b4133831f0438eaa149e5a">xtd::network::http::Server::bind</a> mais se déclenche quelque soit la ressource demandée. <br />
<br />
</li>
<li><div class="fragment"><div class="line"><span class="keywordtype">void</span> bind_default(handler p_handler); </div></div><!-- fragment --> <br />
<br />
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_handler</td><td>handler à enregistrer</td></tr>
  </table>
  </dd>
</dl>
Enregistrement du handler à exécuter lorsqu'aucun handler valide n'a été trouvé. A la construction, le handler par défaut est Server::h_error_template. <br />
<br />
</li>
<li><div class="fragment"><div class="line"><span class="keywordtype">void</span> bind_redirect(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_src, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_dst, [filter p_filter]); </div></div><!-- fragment --> <br />
<br />
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_src</td><td>ressource sur laquelle déclencher la redirection </td></tr>
    <tr><td class="paramname">p_dst</td><td>destination de la redirection </td></tr>
    <tr><td class="paramname">p_filter</td><td>filter "filtre" optionnel</td></tr>
  </table>
  </dd>
</dl>
Enregistrement d'un handler de redirection. Créer une réponse http qui contient le header "Location : p_dst" et le code HTTP Response::STATUS_302. <br />
<br />
</li>
<li><div class="fragment"><div class="line"><span class="keywordtype">void</span> bind_file(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_path,</div><div class="line">               <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_filePath,</div><div class="line">               <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_contentType = <span class="stringliteral">&quot;text/plain&quot;</span>,</div><div class="line">               [filter            p_filter]);</div></div><!-- fragment --> <br />
<br />
 Voir <a class="el" href="classxtd_1_1network_1_1http_1_1Server.html#ab3525557fb71fe7ffec9bf68b61db107">xtd::network::http::Server::h_file</a> <br />
<br />
</li>
<li><div class="fragment"><div class="line"><span class="keywordtype">void</span> bind_dir(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_path,</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_filePath,</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_contentType = <span class="stringliteral">&quot;text/plain&quot;</span>,</div><div class="line">              [filter            p_filter]);</div></div><!-- fragment --> <br />
<br />
 Voir <a class="el" href="classxtd_1_1network_1_1http_1_1Server.html#a7b7fb002ef005e7dd7b502c95587f4f2">xtd::network::http::Server::h_dir</a> <br />
<br />
</li>
</ul>
<h2>Les handlers prédéfinis </h2>
<ul>
<li><div class="fragment"><div class="line">h_redirect(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_dst, <span class="keyword">const</span> uint32_t p_requestId, <span class="keyword">const</span> Request&amp; p_request, Response&amp; p_response); </div></div><!-- fragment --> Handler de redirection. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_dst</td><td>destination de la redirection HTTP </td></tr>
    <tr><td class="paramname">p_requestId</td><td>identifiant de requête </td></tr>
    <tr><td class="paramname">p_request</td><td><a class="el" href="classxtd_1_1network_1_1http_1_1Request.html">requête</a> </td></tr>
    <tr><td class="paramname">p_response</td><td><a class="el" href="classxtd_1_1network_1_1http_1_1Response.html">réponse</a></td></tr>
  </table>
  </dd>
</dl>
Créer une redirection HTTP Response::STATUS_302 "code 302" redirigeant sur p_dst</li>
<li><div class="fragment"><div class="line">h_raw(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_data, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_contentType, <span class="keyword">const</span> uint32_t p_requestId, <span class="keyword">const</span> Request&amp; p_request, Response&amp; p_response); </div></div><!-- fragment --> Handler de contenu. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_data</td><td>donnée à insérer dans la réponse </td></tr>
    <tr><td class="paramname">p_contentType</td><td>type MIME de la donnée </td></tr>
    <tr><td class="paramname">p_response</td><td><a class="el" href="classxtd_1_1network_1_1http_1_1Response.html">réponse</a></td></tr>
  </table>
  </dd>
</dl>
Créer une réponse HTTP (Response::STATUS_200 contenant la donnée p_data et le header <b>Content-Type</b> p_contentType</li>
<li><div class="fragment"><div class="line">h_file(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_filePath, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_contentType, <span class="keyword">const</span> uint32_t p_requestId, <span class="keyword">const</span> Request&amp; p_request, Response&amp; p_response); </div></div><!-- fragment --> Handler de fichier. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_filePath</td><td>chemin vers le fichier à insérer dans la réponse </td></tr>
    <tr><td class="paramname">p_contentType</td><td>type MIME du fichier </td></tr>
    <tr><td class="paramname">p_cachable</td><td>La reponse peut elle mettre en mis en cache par le navigateur ? </td></tr>
    <tr><td class="paramname">p_requestId</td><td>identifiant de requête </td></tr>
    <tr><td class="paramname">p_request</td><td><a class="el" href="classxtd_1_1network_1_1http_1_1Request.html">requête</a> </td></tr>
    <tr><td class="paramname">p_response</td><td><a class="el" href="classxtd_1_1network_1_1http_1_1Response.html">réponse</a></td></tr>
  </table>
  </dd>
</dl>
Créer une réponse HTTP Response::STATUS_200 embarquant le contenu du fichier pointé par p_filePath et le header <b>Content-Type</b> p_contentType. Si p_filePath n'éxiste pas, la réponse sera générée par <a class="el" href="classxtd_1_1network_1_1http_1_1Server.html#ad57a524ff44201af997e2d3557557623">xtd::network::http::Server::h_error_text</a>.</li>
<li><div class="fragment"><div class="line">h_dir(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_dirPath, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_contentType, <span class="keyword">const</span> uint32_t p_requestId, <span class="keyword">const</span> Request&amp; p_request, Response&amp; p_response); </div></div><!-- fragment --> Handler de répertoire. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_dirPath</td><td>chemin vers le répertoire à servir </td></tr>
    <tr><td class="paramname">p_contentType</td><td>type MIME des fichiers du répertoire </td></tr>
    <tr><td class="paramname">p_cachable</td><td>La reponse peut elle mettre en mis en cache par le navigateur ? </td></tr>
    <tr><td class="paramname">p_requestId</td><td>identifiant de requête </td></tr>
    <tr><td class="paramname">p_request</td><td><a class="el" href="classxtd_1_1network_1_1http_1_1Request.html">requête</a> </td></tr>
    <tr><td class="paramname">p_response</td><td><a class="el" href="classxtd_1_1network_1_1http_1_1Response.html">réponse</a></td></tr>
  </table>
  </dd>
</dl>
Comme <a class="el" href="classxtd_1_1network_1_1http_1_1Server.html#ab3525557fb71fe7ffec9bf68b61db107">xtd::network::http::Server::h_file</a> mais trouve automatiquement quel fichier de p_dirPath à servir en fonction de la ressource demandé dans p_request.</li>
<li><div class="fragment"><div class="line">h_template_file(<span class="keyword">const</span> Template&amp; p_tmpl, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; <span class="keyword">const</span> uint32_t p_requestID, <span class="keyword">const</span> Request&amp; p_request, Response&amp; p_response); </div></div><!-- fragment --> Handler de texte templaté a partir d'un fichier. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_tmpl</td><td>objet <a class="el" href="classxtd_1_1network_1_1http_1_1Template.html">template</a> </td></tr>
    <tr><td class="paramname">p_filePath</td><td>fichier a partir duquel initialiser le template </td></tr>
    <tr><td class="paramname">p_requestID</td><td>identifiant de requête </td></tr>
    <tr><td class="paramname">p_req</td><td><a class="el" href="classxtd_1_1network_1_1http_1_1Request.html">requête</a> </td></tr>
    <tr><td class="paramname">p_res</td><td><a class="el" href="classxtd_1_1network_1_1http_1_1Response.html">réponse</a></td></tr>
  </table>
  </dd>
</dl>
Génère une réponse HTTP pré-formatée par l'objet Template p_tmpl Response::STATUS_200. Le header <b>Content-Type</b> est également donné par p_tmpl. Si la lecture du fichier p_filePath ou si la résolution des variable du template échouent, alors la réponse sera générée par <a class="el" href="classxtd_1_1network_1_1http_1_1Server.html#ad57a524ff44201af997e2d3557557623">xtd::network::http::Server::h_error_text</a>.</li>
<li><div class="fragment"><div class="line">h_error_text(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_message, <span class="keyword">const</span> uint32_t p_requestId, <span class="keyword">const</span> Request&amp; p_request, Response&amp; p_response); </div></div><!-- fragment --> Handler de génération de message d'erreur en texte. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_message</td><td>contenu du message d'erreur </td></tr>
    <tr><td class="paramname">p_requestId</td><td>identifiant de requête </td></tr>
    <tr><td class="paramname">p_request</td><td><a class="el" href="classxtd_1_1network_1_1http_1_1Request.html">requête</a> </td></tr>
    <tr><td class="paramname">p_response</td><td><a class="el" href="classxtd_1_1network_1_1http_1_1Response.html">réponse</a></td></tr>
  </table>
  </dd>
</dl>
Génère une réponse HTTP d'erreur Response::STATUS_500 de type <b>Content-Type</b> "text/plain" contenant le message p_message.</li>
<li><div class="fragment"><div class="line">h_error_html(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_message, <span class="keyword">const</span> uint32_t p_requestId, <span class="keyword">const</span> Request&amp; p_request, Response&amp; p_response); </div></div><!-- fragment --> Handler de génération de message d'erreur en html. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_message</td><td>contenu du message d'erreur </td></tr>
    <tr><td class="paramname">p_requestId</td><td>identifiant de requête </td></tr>
    <tr><td class="paramname">p_request</td><td><a class="el" href="classxtd_1_1network_1_1http_1_1Request.html">requête</a> </td></tr>
    <tr><td class="paramname">p_response</td><td><a class="el" href="classxtd_1_1network_1_1http_1_1Response.html">réponse</a></td></tr>
  </table>
  </dd>
</dl>
Même chose que <a class="el" href="classxtd_1_1network_1_1http_1_1Server.html#ad57a524ff44201af997e2d3557557623">xtd::network::http::Server::h_error_text</a> mais le message généré est de type "text/html".</li>
</ul>
<h2>Les filtres prédéfinis </h2>
<ul>
<li><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">bool</span> f_none(<span class="keyword">const</span> Request&amp; p_request); </div></div><!-- fragment --> Toujours vrai. <br />
<br />
 <br />
<br />
</li>
<li><div class="fragment"><div class="line"><span class="keywordtype">bool</span> f_cgi_exist(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_cgiName, <span class="keyword">const</span> Request&amp; p_request); </div></div><!-- fragment --> Vrai si la requête contient un paramètre GET nommé p_cgiName. <br />
<br />
 <br />
<br />
</li>
<li><div class="fragment"><div class="line"><span class="keywordtype">bool</span> f_one_cgi_exist(<span class="keyword">const</span> vector &lt;string &gt; &amp; p_cgiName, <span class="keyword">const</span> Request&amp; p_req); </div></div><!-- fragment --> <br />
<br />
 Vrai si la requête contient un paramètre GET dont le nom correspond à l'un des éléments du tableau p_cgiName <br />
<br />
</li>
<li><div class="fragment"><div class="line"><span class="keywordtype">bool</span> f_cgi_equal(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_cgiName, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_value, <span class="keyword">const</span> Request&amp; p_request); </div></div><!-- fragment --> <br />
<br />
 Vrai si la requête contient un paramètre GET nommé p_cgiName et dont la valeur est égale à p_value <br />
<br />
</li>
<li><div class="fragment"><div class="line"><span class="keywordtype">bool</span> f_cgi_match(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_cgiName, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_regex, <span class="keyword">const</span> Request&amp; p_request); </div></div><!-- fragment --> <br />
<br />
 Vrai si la requête contient un paramètre GET nommé p_cgiName et dont la valeur match la regexp p_regex <br />
<br />
</li>
<li><div class="fragment"><div class="line"><span class="keywordtype">bool</span> f_post_exist(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_cgiName, <span class="keyword">const</span> Request&amp; p_request); </div></div><!-- fragment --> Vrai si la requête contient un paramètre POST nommé p_cgiName. <br />
<br />
 <br />
<br />
</li>
<li><div class="fragment"><div class="line"><span class="keywordtype">bool</span> f_post_equal(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_cgiName, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_value, <span class="keyword">const</span> Request&amp; p_request); </div></div><!-- fragment --> <br />
<br />
 Vrai si la requête contient un paramètre POST nommé p_cgiName et dont la valeur est égale à p_value <br />
<br />
</li>
<li><div class="fragment"><div class="line"><span class="keywordtype">bool</span> f_post_match(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_cgiName, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_regex, <span class="keyword">const</span> Request&amp; p_request); </div></div><!-- fragment --> <br />
<br />
 Vrai si la requête contient un paramètre POST nommé p_cgiName et dont la valeur match la regexp p_regex <br />
<br />
</li>
<li><div class="fragment"><div class="line"><span class="keywordtype">bool</span> f_header_exist(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_headerName, <span class="keyword">const</span> Request&amp; p_request); </div></div><!-- fragment --> Vrai si p_request contient le header p_headerName. <br />
<br />
 <br />
<br />
</li>
<li><div class="fragment"><div class="line"><span class="keywordtype">bool</span> f_header_equal(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_headerName, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_value, <span class="keyword">const</span> Request&amp; p_request); </div></div><!-- fragment --> <br />
<br />
 Vrai si p_request contient le header p_headerName dont la valeur est egale a p_value <br />
<br />
</li>
<li><div class="fragment"><div class="line"><span class="keywordtype">bool</span> f_header_match(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_headerName, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; p_value, <span class="keyword">const</span> Request&amp; p_request); </div></div><!-- fragment --> <br />
<br />
 Vrai si p_request contient le header p_headerName dont la valeur match la regexp p_value <br />
<br />
</li>
</ul>
<hr/>
 <h1><a class="anchor" id="sec_usages"></a>
Matrice d'utilisation</h1>
<hr/>
<ul>
<li>
matrices des utilisations dans le moteurs  </li>
</ul>
<hr/>
 <h1><a class="anchor" id="sec_tests"></a>
Les tests</h1>
<hr/>
<ul>
<li>
cachier de tests  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
